CREATE TABLE "service" (
  "service_id" serial PRIMARY KEY,
  "service_title" text,
  "service_cost" varchar
);

CREATE TABLE "log_of_visits" (
  "record_id" serial PRIMARY KEY,
  "visit_date" date,
  "client_id" integer,
  "the_receiving_veterinarian_id" integer,
  "service_id" integer,
  "medicine_used_id" text,
  "visit_time" time,
  "confirmation_of_the_reception" boolean
);

CREATE TABLE "the_medicine_used" (
  "medicine_used_id" serial PRIMARY KEY,
  "visit_id" integer,
  "amount_of_medicine_used" varchar,
  "medicine_id" integer
);

CREATE TABLE "medicine" (
  "medicine_id" serial PRIMARY KEY,
  "medicine_name" text,
  "description" text
);

CREATE TABLE "purchase" (
  "purchase_id" serial PRIMARY KEY,
  "purchase_date" date,
  "medicine_id" integer,
  "provider_id" integer,
  "purchase_cost" varchar
);

CREATE TABLE "provider" (
  "provider_id" serial PRIMARY KEY,
  "provider_title" text,
  "provider_email" text,
  "provider_phone_number" varchar
);

CREATE TABLE "client" (
  "client_id" serial PRIMARY KEY,
  "client_surname" text,
  "client_name" text,
  "client_second_name" text,
  "client_address" text,
  "client_phone_number" varchar,
  "client_email" text,
  "note_of_client" text
);

CREATE TABLE "employee" (
  "employee_id" serial PRIMARY KEY,
  "employee_surname" text,
  "employee_name" text,
  "employee_second_name" text,
  "employee_phone_number" varchar,
  "employee_email" text,
  "employee_post_id" integer,
  "note_of_employee" text,
  "employee_birthday" date
);

CREATE TABLE "pet" (
  "pet_id" serial PRIMARY KEY,
  "client_id" integer,
  "anim_type_id" integer,
  "breed_of_animal" text,
  "pets_nickname" text,
  "gender_of_the_pet" text,
  "anim_birthday" date,
  "note_of_pet" text
);

CREATE TABLE "anim_type" (
  "anim_type_id" serial PRIMARY KEY,
  "anim_type_name" text
);


CREATE TABLE "post" (
  "employee_post_id" serial PRIMARY KEY,
  "employee_post_name" text
);



ALTER TABLE "log_of_visits" ADD FOREIGN KEY ("service_id") REFERENCES "service" ("service_id") ON DELETE CASCADE;

ALTER TABLE "log_of_visits" ADD FOREIGN KEY ("client_id") REFERENCES "client" ("client_id") ON DELETE CASCADE;

ALTER TABLE "log_of_visits" ADD FOREIGN KEY ("the_receiving_veterinarian_id") REFERENCES "employee" ("employee_id") ON DELETE CASCADE;

ALTER TABLE "the_medicine_used" ADD FOREIGN KEY ("visit_id") REFERENCES "log_of_visits" ("record_id") ON DELETE CASCADE;

ALTER TABLE "the_medicine_used" ADD FOREIGN KEY ("medicine_id") REFERENCES "medicine" ("medicine_id") ON DELETE CASCADE;

ALTER TABLE "purchase" ADD FOREIGN KEY ("medicine_id") REFERENCES "medicine" ("medicine_id") ON DELETE CASCADE;

ALTER TABLE "pet" ADD FOREIGN KEY ("client_id") REFERENCES "client" ("client_id") ON DELETE CASCADE;

ALTER TABLE "pet" ADD FOREIGN KEY ("anim_type_id")  REFERENCES "anim_type" ("anim_type_id") ON DELETE CASCADE;

ALTER TABLE "purchase" ADD FOREIGN KEY ("provider_id") REFERENCES "provider" ("provider_id") ON DELETE CASCADE;

ALTER TABLE "employee" ADD FOREIGN KEY ("employee_post_id") REFERENCES "post" ("employee_post_id") ON DELETE CASCADE;


/*
CREATE ROLE db_admin WITH NOLOGIN;

CREATE ROLE manager WITH NOLOGIN;

CREATE ROLE veterinarian WITH NOLOGIN;

CREATE ROLE client_vet_as WITH NOLOGIN;


CREATE USER adm1 WITH PASSWORD '1';
GRANT db_admin TO adm1;

CREATE USER man1 WITH PASSWORD '11';
GRANT manager TO man1;

CREATE USER vet1 WITH PASSWORD '111';
GRANT veterinarian TO vet1;

CREATE USER cl1 WITH PASSWORD '1111';
GRANT client_vet_as TO cl1;
*/
GRANT SELECT, INSERT, UPDATE, DELETE ON service, log_of_visits, the_medicine_used, medicine, pet, purchase, provider, client, employee, anim_type, post TO db_admin;
GRANT SELECT, INSERT, UPDATE ON service, log_of_visits, the_medicine_used, medicine, pet, purchase, provider, client, employee TO manager;
GRANT SELECT, INSERT, UPDATE, DELETE ON service, log_of_visits, the_medicine_used, medicine, pet, client, employee, anim_type, post TO veterinarian;
GRANT SELECT, INSERT, UPDATE ON service, log_of_visits, client, pet, anim_type TO client_vet_as;

GRANT USAGE, SELECT ON SEQUENCE service_service_id_seq, log_of_visits_record_id_seq, the_medicine_used_medicine_used_id_seq, anim_type_anim_type_id_seq,  medicine_medicine_id_seq, pet_pet_id_seq, purchase_purchase_id_seq, provider_provider_id_seq, client_client_id_seq, employee_employee_id_seq, post_employee_post_id_seq TO db_admin;
GRANT USAGE, SELECT ON SEQUENCE service_service_id_seq, log_of_visits_record_id_seq, the_medicine_used_medicine_used_id_seq, anim_type_anim_type_id_seq,  medicine_medicine_id_seq, pet_pet_id_seq, purchase_purchase_id_seq, provider_provider_id_seq, client_client_id_seq, employee_employee_id_seq TO manager;
GRANT USAGE, SELECT ON SEQUENCE service_service_id_seq, log_of_visits_record_id_seq, the_medicine_used_medicine_used_id_seq, anim_type_anim_type_id_seq,  medicine_medicine_id_seq, pet_pet_id_seq, client_client_id_seq, employee_employee_id_seq TO veterinarian;
GRANT USAGE, SELECT ON SEQUENCE service_service_id_seq, log_of_visits_record_id_seq, anim_type_anim_type_id_seq,  pet_pet_id_seq, client_client_id_seq TO client_vet_as;


CREATE OR REPLACE FUNCTION check_visit_date_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, является ли дата воскресеньем
    IF EXTRACT(DOW FROM NEW.visit_date) = 0 THEN
        RAISE EXCEPTION 'Appointments cannot be scheduled on Sunday';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_visit_date_trigger
BEFORE INSERT ON log_of_visits
FOR EACH ROW
EXECUTE FUNCTION check_visit_date_function();


CREATE OR REPLACE FUNCTION check_visit_time_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, находится ли время приема в пределах с 8:00 до 22:00
    IF EXTRACT(HOUR FROM NEW.visit_time) < 8 OR EXTRACT(HOUR FROM NEW.visit_time) >= 22 THEN
        RAISE EXCEPTION 'Appointments cannot be scheduled earlier than 8 AM or later than 10 PM';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_visit_time_trigger
BEFORE INSERT ON log_of_visits
FOR EACH ROW
EXECUTE FUNCTION check_visit_time_function();



CREATE OR REPLACE FUNCTION check_future_visit_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, есть ли у клиента предстоящие приемы
    IF EXISTS (
        SELECT 1 FROM log_of_visits
        WHERE client_id = OLD.client_id
        AND visit_date > NOW()
    ) THEN
        RAISE EXCEPTION 'Cannot delete client with future appointments';
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_future_visit_trigger
BEFORE DELETE ON client
FOR EACH ROW
EXECUTE FUNCTION check_future_visit_function();


--для сотрудников
CREATE OR REPLACE FUNCTION check_employee_age()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, старше ли сотрудник 18 лет
    IF NEW.employee_birthday > CURRENT_DATE - INTERVAL '18 year' THEN
        RAISE EXCEPTION 'Employee must be at least 18 years old';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_employee_age_trigger
BEFORE INSERT ON employee
FOR EACH ROW
EXECUTE FUNCTION check_employee_age();


--для сотрудников

CREATE OR REPLACE FUNCTION check_employee_email_format_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, соответствует ли email маске
    IF NEW.employee_email !~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.employee_email;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_employee_email_format_trigger
BEFORE INSERT OR UPDATE ON employee
FOR EACH ROW
EXECUTE FUNCTION check_employee_email_format_function();

--для клиентов

CREATE OR REPLACE FUNCTION check_email_format_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, соответствует ли email маске
    IF NEW.client_email !~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$' THEN
        RAISE EXCEPTION 'Invalid email format: %', NEW.client_email;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_email_format_trigger
BEFORE INSERT OR UPDATE ON client
FOR EACH ROW
EXECUTE FUNCTION check_email_format_function();

--

CREATE OR REPLACE FUNCTION check_client_phone_number_format()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, соответствует ли номер телефона маске
    IF NEW.client_phone_number !~* '^\+7[0-9]{10}$' THEN
        RAISE EXCEPTION 'Invalid phone number format: %', NEW.client_phone_number;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_client_phone_number_format_trigger
BEFORE INSERT OR UPDATE ON client
FOR EACH ROW
EXECUTE FUNCTION check_client_phone_number_format();

--

CREATE OR REPLACE FUNCTION check_employee_phone_number_format()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, соответствует ли номер телефона маске
    IF NEW.employee_phone_number !~* '^\+7[0-9]{10}$' THEN
        RAISE EXCEPTION 'Invalid phone number format: %', NEW.employee_phone_number;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_employee_phone_number_format_trigger
BEFORE INSERT OR UPDATE ON employee
FOR EACH ROW
EXECUTE FUNCTION check_employee_phone_number_format();

--

CREATE OR REPLACE FUNCTION check_duplicate_appointment_function()
RETURNS TRIGGER AS $$
BEGIN
    -- Проверяем, существует ли уже запись к тому же врачу на ту же дату и время
    IF EXISTS (
        SELECT * FROM log_of_visits
        WHERE the_receiving_veterinarian_id = NEW.the_receiving_veterinarian_id
        AND visit_date = NEW.visit_date
	AND visit_time = NEW.visit_time
    ) THEN
        RAISE EXCEPTION 'Appointment already exists for this doctor at this date and time';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER check_duplicate_appointment_trigger
BEFORE INSERT OR UPDATE ON log_of_visits
FOR EACH ROW
EXECUTE FUNCTION check_duplicate_appointment_function();


--

CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE OR REPLACE FUNCTION encrypt_employee_data_function()
RETURNS TRIGGER AS $$
DECLARE
    key_s TEXT := 'my_secret_key_for_vet_as'; -- Секретный ключ для шифрования
BEGIN
    -- Шифрование данных перед вставкой или обновлением
    NEW.employee_surname := pgp_sym_encrypt(NEW.employee_surname, key_s, 'cipher-algo=aes256');
    NEW.employee_name := pgp_sym_encrypt(NEW.employee_name, key_s, 'cipher-algo=aes256');
	NEW.employee_second_name := pgp_sym_encrypt(NEW.employee_second_name, key_s, 'cipher-algo=aes256');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER bencrypt_employee_data_trigger
BEFORE INSERT OR UPDATE ON employee
FOR EACH ROW
EXECUTE FUNCTION encrypt_employee_data_function();


CREATE OR REPLACE VIEW decrypted_employees AS
SELECT
    pgp_sym_decrypt(employee_surname::bytea, 'my_secret_key_for_vet_as')::text as employee_surname_d,
    pgp_sym_decrypt(employee_name::bytea, 'my_secret_key_for_vet_as')::text as employee_name_d,
    pgp_sym_decrypt(employee_second_name::bytea, 'my_secret_key_for_vet_as')::text as employee_second_name_d
FROM employee;

/*
select * from decrypted_employees
*/
--------------------------------------------------------------




